---
title: "코테-기능개발"
date: 2020-10-01 16:34:28 -0400
categories: Javascript
---

문제 설명
---
프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.

또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.

먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.

제한 사항
---
작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.
작업 진도는 100 미만의 자연수입니다.
작업 속도는 100 이하의 자연수입니다.
배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.

입출력 예
---
progresses	speeds	return
[93, 30, 55]	[1, 30, 5]	[2, 1]
[95, 90, 99, 99, 80, 99]	[1, 1, 1, 1, 1, 1]	[1, 3, 2]

입출력 예 설명
---
입출력 예 #1
첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.
두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.
세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.

따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.

입출력 예 #2
모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.

따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.

코드
---
``` javascript
function solution(progresses, speeds) {
    var answer = [];
    while (progresses.length > 0) {
        progresses = progresses.map((a, b) => a + speeds[b]);
        var count = 0;
        for (var i = 0; i < progresses.length; i++) {
            if (progresses[i] < 100){
                break; // 100이 안될 경우는 for문을 종료
            } else {
                count++; // 100이 될경우 count 값 증가
            }
        }
        if(count) {
            answer.push(count);
            for (var i = 0; i < count; i++) {
                progresses.shift();
                speeds.shift();
            }
        }
    }
    return answer;
}
```

풀이
---
``` javascript
while (progresses.length > 0)
```
위 코드는 while문을 통해 progresses내의 값이 존재할 경우에는 계속
하기 코드를 반복하겠다는 의미이다. 이렇게 푼 이유는 문제의 주제가 스택/큐이기에
배열 내의 요소를 제거하면서 가겠다는 생각을 가지고, 요소가 전부 제거 될 경우 코드를
끝내고 결과를 도출하기 위함이다.

``` javascript
progresses = progresses.map((a, b) => a + speeds[b]);
```
예제1의 내용을 기반으로 map의 결과값을 도출하면 [94, 60, 60]이 된다.
map의 첫번째 인자는 문자열 혹은 배열의 값이며 두번째 값은 그 값의 인덱스를 의미하기 때문이다.
문제와 같은 내용으로 적용하면 1일이 지난 후의 작업량(%)를 의미한다.
이후에 변수 count를 선언하고, 0이라는 값을 할당하였다. 이후에 조건문에 따라 증감이 될 예정이다.

``` javascript
for (var i = 0; i < progresses.length; i++) {
    if (progresses[i] < 100){
        break; // 100이 안될 경우는 for문을 탈출
    } else {
        count++; // 100이 될경우 count 값 증가
    }
}
```

for문은 위 주석으로 적어놓은 내용을 참고하면 된다.
코드 작동 순서는 이러하다.(고민은 하였지만, 실제로 작동과정에 차이가 있을 수있다.)
``` javascript
if(count) {
    answer.push(count);
    for (var i = 0; i < count; i++) {
        progresses.shift();
        speeds.shift();
    }
}
```
break가 끝난 이후에는 위 코드가 실행이되지만,
count가 0이기 때문에 작동하기 않고 while문으로 인하여
다시 처음부터 반복한다. 이를 반복하며, progresses[0]의 값이
100이상이 되었을때, count++이 진행되며, 이 다음엔
for문에 의하여 progresses[1]의 값을 체크하고
100이상일 경우 count++을 진행하고
100미만일 경우에는 for문을 탈출하여 다음 if문을 실행하게 된다.
그리고 count값이 이제 0이 아니므로, 그 아래 조건식을 실행하게 되는데
일단 결과값으로 도출될 배열 answer에 count값을 push로 넣어준 후
count의 값만큼 for문을 돌려, progresses와 speeds의 제일 앞 요소를
제거해준다. 이 과정을 통해 progresses 배열의 요소가 점차 줄어들게 되면서
비로소 length가 0이 되었을 때, 즉 모든 것이 100이상이 되어 shift()가 되었을 때
while문이 종료되며, return answer; 코드가 실행되게 된다.

느낀 점
---
일단 코테 2단계를 처음 진행하였고, 1단계보다 훨씬 긴 지문과 그에 따른 추가적인 조건들이
주어지니 1단계처럼 단순하게 풀이를 생각해내지 못했다.(물론 1단계도 어려웠다.)
기본적으로 수학과 같이 이러한 유형을 겪지 못했고, 경험의 부족 각종 메소드의 활용능력 부족과
같은 기본기 부족으로 발생되는 문제이므로 계속 부딪히며, 경험하는게 방법인 듯하다.
